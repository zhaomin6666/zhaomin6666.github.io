<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico"><link rel="icon" type="image/png" sizes="32x32" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico"><link rel="icon" type="image/png" sizes="16x16" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico"><link rel="mask-icon" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"zm6666.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="目录  Kafka简介和安装以及原生命令行客户端 这块主要是一个Kafka所包含的内部元素的介绍以及简单的使用。 Java客户端以及Spring集成 Java客户端其实就是原生命令行的一种封装，学习如何使用即可，Spring就是在这个基础上再进行了对象的管理，使用起来并不难。 Kafka集群架构设计（本篇） Kafka在设计之初就是为了高吞吐、高性能、高可扩展，所以它的集群架构是"><meta property="og:type" content="article"><meta property="og:title" content="Kafka使用指南3——Kafka集群架构设计"><meta property="og:url" content="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/index.html"><meta property="og:site_name" content="Oli的生活杂谈"><meta property="og:description" content="目录  Kafka简介和安装以及原生命令行客户端 这块主要是一个Kafka所包含的内部元素的介绍以及简单的使用。 Java客户端以及Spring集成 Java客户端其实就是原生命令行的一种封装，学习如何使用即可，Spring就是在这个基础上再进行了对象的管理，使用起来并不难。 Kafka集群架构设计（本篇） Kafka在设计之初就是为了高吞吐、高性能、高可扩展，所以它的集群架构是"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-04-10T02:40:21.000Z"><meta property="article:modified_time" content="2024-07-22T13:24:24.850Z"><meta property="article:tag" content="Java"><meta property="article:tag" content="Kafka"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/","path":"分布式框架Distribute-framework/How-to-use-Kafka-3-Cluster/","title":"Kafka使用指南3——Kafka集群架构设计"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Kafka使用指南3——Kafka集群架构设计 | Oli的生活杂谈</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?a2fa2913e1140bc40e9aef85d103226c"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Oli的生活杂谈</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">2.</span> <span class="nav-text">主要内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kafka%E5%9C%A8zookeeper%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">Kafka在Zookeeper中存储的数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#broker%E7%9A%84controller%E9%80%89%E4%B8%BE"><span class="nav-number">4.</span> <span class="nav-text">Broker的Controller选举</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#partition%E7%9A%84leader%E9%80%89%E4%B8%BE"><span class="nav-number">5.</span> <span class="nav-text">Partition的Leader选举</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#partition%E7%9A%84leader%E8%87%AA%E5%8A%A8%E5%B9%B3%E8%A1%A1"><span class="nav-number">6.</span> <span class="nav-text">Partition的Leader自动平衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#partition%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">Partition故障恢复机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hw%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">8.</span> <span class="nav-text">HW一致性保证</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.</span> <span class="nav-text">数据丢失问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">数据不一致问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3epoch"><span class="nav-number">9.</span> <span class="nav-text">问题的解决——Epoch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">9.1.</span> <span class="nav-text">解决数据丢失问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="nav-number">9.2.</span> <span class="nav-text">解决数据不一致问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="" src="https://myblog-1303447677.file.myqcloud.com/BlogFrame/my-avatar.png"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/zhaomin6666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaomin6666" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:lanmao_1029@163.com" title="E-Mail → mailto:lanmao_1029@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://myblog-1303447677.file.myqcloud.com/BlogFrame/my-avatar.png"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Oli的生活杂谈"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Kafka使用指南3——Kafka集群架构设计 | Oli的生活杂谈"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Kafka使用指南3——Kafka集群架构设计</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-04-10 10:40:21" itemprop="dateCreated datePublished" datetime="2024-04-10T10:40:21+08:00">2024-04-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-07-22 21:24:24" itemprop="dateModified" datetime="2024-07-22T21:24:24+08:00">2024-07-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/" itemprop="url" rel="index"><span itemprop="name">分布式框架Distribute-framework</span></a></span></span><span id="/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/" class="post-meta-item leancloud_visitors" data-flag-title="Kafka使用指南3——Kafka集群架构设计" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><hr><h1 id="目录">目录</h1><ol type="1"><li><p>Kafka简介和安装以及原生命令行客户端</p><p>这块主要是一个Kafka所包含的内部元素的介绍以及简单的使用。</p></li><li><p>Java客户端以及Spring集成</p><p>Java客户端其实就是原生命令行的一种封装，学习如何使用即可，Spring就是在这个基础上再进行了对象的管理，使用起来并不难。</p></li><li><p>Kafka集群架构设计（本篇）</p><p>Kafka在设计之初就是为了高吞吐、高性能、高可扩展，所以它的集群架构是非常值得学习的。</p></li><li><p>Kafka日志索引详解</p><p>Broker能够高效地处理和保存消息，是Kafka高性能的保障。我们从可见的log文件入手，去研究一下Kafka是如何保证消息高效的流转。</p></li></ol><h1 id="主要内容">主要内容</h1><p>这一部分主要是理解Kafka的服务端重要原理。但是Kafka为了保证高吞吐，高性能，高可扩展的三高架构，很多具体设计都是相当复杂的。我们会从数据存储入手一起探讨Kafka的集群设计。</p><span id="more"></span><hr><h1 id="kafka在zookeeper中存储的数据">Kafka在Zookeeper中存储的数据</h1><p>Kafka将状态信息保存在Zookeeper中，这些状态信息保存了每个Broker服务的状态和信息。这些信息需要在每个Broker之间达成共识，所以统一保存在独立于所有Broker的中间件中。</p><p>这些共识数据需要保证强一致性，这样才能保证各Broker之间分工明确。基于CP的Zookeeper就成为了Kafka的首要选择，目前Kafka为了实现云原生推出的Kraft还有一段实践的要走。另外Zookeeper的watcher机制也可以很好的减少Broker读取Zookeeper的次数。</p><p>我们会回忆一下在第一篇文章中介绍的Zookeeper的架构，Kafka集群中最为主要的状态信息有两个，一个是多个Broker需要有一个Controller，一个是多个Partition需要有一个Leader。</p><ol type="1"><li>选举一个Broker作为Controller。由Controller节点来管理整个集群中的分区和副本状态。</li><li>一个Topic下选举一个Partition作为Leader。由Leader角色的Partition来负责和客户端交互。</li></ol><p>我们使用<a target="_blank" rel="noopener" href="https://github.com/vran-dev/PrettyZoo/releases">PreetyZoo工具</a>查看Zookeeper中的数据如下，其中带<code>▼</code>的说明有子节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">▼admin</span><br><span class="line">	delete topics</span><br><span class="line">▼brokers</span><br><span class="line">	▼ids</span><br><span class="line">		0</span><br><span class="line">		1</span><br><span class="line">		2</span><br><span class="line">	 seqid</span><br><span class="line">	▼topics</span><br><span class="line">▼cluster</span><br><span class="line">▼config</span><br><span class="line"> consumers</span><br><span class="line"> controller</span><br><span class="line"> controller epoch</span><br><span class="line"> feature</span><br><span class="line"> isr_change_notification</span><br><span class="line"> latest_producer_id_block</span><br><span class="line"> log_dir_event_notification</span><br></pre></td></tr></table></figure><p>对于Kafka保存在Zookeeper中的数据，大部分是比较明了的。比如<code>/brokers</code>目录下，<code>/ids</code>目录就保存了对应集群中broker的brokerId，<code>/topics</code>目录就保存了各个topic及topic下partition的信息。</p><p>我们做一个简单的验证，在每启动一个新节点的时候查看<code>/ids</code>目录，当启动完brokerId分别为0和1的两个节点之后，我们查看/ids节点为<code>[0, 1]</code>，此时手动往<code>/ids</code>目录下加上<code>2</code>这个节点，会导致brokerId为3无法启动，启动日志中提示<code>NodeExists</code>。</p><h1 id="broker的controller选举">Broker的Controller选举</h1><p>在Kafka集群开始工作之前，需要从Broker中选举出一个Controller来充当管理角色，负责管理集群中分区和副本状态。</p><p><strong>选举是通过占用Zookeeper的<code>controller</code>节点实现的。</strong></p><p>当一个集群内的Kafka节点启动时，就会尝试往Zookeeper上创建一个<code>/controller</code>临时节点，并将自己的brokerId写入这个节点，我们可以查看目前集群下的<code>/controller</code>节点数据看一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brokerid&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1712729219749&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kraftControllerEpoch&quot;</span> <span class="punctuation">:</span> <span class="number">-1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中<code>brokerid</code>标识当前的controller为id为0的broker，timestamp为时间戳。version是为Kraft而修改的值，之前为1，kraftControllerEpoch也是为Kraft新增的值，这两项修改感兴趣可以自行查看<a target="_blank" rel="noopener" href="https://github.com/apache/kafka/pull/12928">KAFKA-14304 Add RPC changes, records, and config from KIP-866</a>，和Kraft相关的这边就先不详细研究了。</p><p>Zookeeper会保证一个集群中只有一个broker能够成功创建这个节点。这个注册成功的broker就成了这个集群中的Controller节点。</p><p>当一个应用在Zookeeper上创建了一个临时节点之后，Zookeeper需要这个应用一直保持连接状态。如果Zookeeper长时间检测不到应用的心跳信息，就会删除节点。同时Zookeeper还允许应用监听节点的状态，当应用状态有变化时，会向该节点对应的所有监听器广播节点变化信息。</p><p>这样，如果集群中的Controller节点宕机了，Zookeeper就会删除<code>/controller</code>节点，而其他未注册成功的Broker节点就会感知到这一事件并开始竞争，直到一个新的broker成功创建<code>/controller</code>节点。这就是Kafka基于Zookeeper选举Controller的机制。</p><p>选举产生的Controller节点会负责监听Zookeeper中一些关键数据的变化，触发集群的相关管理工作。</p><ol type="1"><li>监听<code>/brokers/ids</code>节点，感知Broker的增减变化。</li><li>监听<code>/brokers/topics</code>节点，感知Topic以及对应partition的增减变化。</li><li>监听<code>/admin/delete_topic</code>节点，处理删除Topic事件。</li></ol><p>另外Controller还负责把元数据推送给其他Broker。</p><h1 id="partition的leader选举">Partition的Leader选举</h1><p>在Kafka中，一个Topic下的所有消息，是分开存储在不同的Partition中的。在使用<code>kafka-topics.sh</code>脚本创建Topic时，可以通过<code>--partitions</code>参数指定Topic下包含多少个Partition，还可以通过<code>--replication-factors</code>参数指定每个Partition有几个备份。而在一个Partition的众多备份中，需要选举出一个Leader Partition，负责对接所有的客户端请求，并将消息优先保存，然后再通知其他Follower Partition来同步消息。</p><p>在理解Partition的Leader选举之前，我们回顾一下第一篇文章中的一些基本概念：</p><ul><li>AR：Assigned Replicas。表示Kafka分区中所有的副本（存活或者不存活的）。</li><li>ISR：In Sync Replicas。表示在所有AR中，服务正常，保持与Leader同步的副本集合。如果Follower长时间没有向Leader发送通信请求（超时时间由<code>replica.lag.time.max.ms</code>决定，默认30s），那么这个Follower就会被提出ISR。</li></ul><p>可以通过<code>kafka-topics.sh</code>的<code>--describe</code>指令查看AR和ISR。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test-multi-1</span></span><br><span class="line">Topic: test-multi-1     TopicId: uHfcZjY4T-SaBfR_ezgsXA PartitionCount: 2       ReplicationFactor: 3    Configs:</span><br><span class="line">        Topic: test-multi-1     Partition: 0    Leader: 2       Replicas: 2,1,0 Isr: 0,1,2</span><br><span class="line">        Topic: test-multi-1     Partition: 1    Leader: 1       Replicas: 1,0,2 Isr: 0,1,2</span><br></pre></td></tr></table></figure><p>这个结果中，AR就是Replicas的集合。这些数据的来源都是Zookeeper，我们在Zookeeper中再来看一下这些数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▼topics</span><br><span class="line">	▼consumer offsets</span><br><span class="line">	▼test</span><br><span class="line">	▼test-multi-1</span><br><span class="line">        ▼partitions</span><br><span class="line">            ▼0</span><br><span class="line">                state</span><br><span class="line">            ▼1</span><br><span class="line">                state</span><br></pre></td></tr></table></figure><p>在对应的<code>/topic</code>下找到对应的topic，我们查看<code>/topic</code>节点数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;partitions&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;0&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;1&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">2</span> <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;topic_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;uHfcZjY4T-SaBfR_ezgsXA&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;adding_replicas&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;removing_replicas&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可查看对应的partition为0信息，我们查看<code>/state</code>节点数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;controller_epoch&quot;</span> <span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;leader&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;leader_epoch&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isr&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在进行Partition的选举的时候，Kafka会从该Topic的AR中选择排名靠前的优先选举，也就是我们看到<code>/topic</code>节点下<code>"partition":"0"</code>的列表中靠前的优先选举。如上面的实例，当Leader节点（brokerId=2）宕机时，brokerId=1的节点就会被选举成Leader。</p><p>我们从Kafka的<code>--describe</code>指令来看一下选举的过程，初始状态如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test-multi-1</span></span><br><span class="line">Topic: test-multi-1     TopicId: uHfcZjY4T-SaBfR_ezgsXA PartitionCount: 2       ReplicationFactor: 3    Configs:</span><br><span class="line">        Topic: test-multi-1     Partition: 0    Leader: 2       Replicas: 2,1,0 Isr: 0,1,2</span><br><span class="line">        Topic: test-multi-1     Partition: 1    Leader: 1       Replicas: 1,0,2 Isr: 0,1,2</span><br></pre></td></tr></table></figure><p>如果此时我们关闭brokerId为2的机器上的kafka服务，再执行命令查看状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test-multi-1</span></span><br><span class="line">Topic: test-multi-1     TopicId: uHfcZjY4T-SaBfR_ezgsXA PartitionCount: 2       ReplicationFactor: 3    Configs:</span><br><span class="line">        Topic: test-multi-1     Partition: 0    Leader: 1       Replicas: 2,1,0 Isr: 0,1</span><br><span class="line">        Topic: test-multi-1     Partition: 1    Leader: 1       Replicas: 1,0,2 Isr: 0,1</span><br></pre></td></tr></table></figure><p>可以看到AR中并没有删除id为2的broker，而Isr的列表中id为2的记录已经没有了，同时Leader也从id为2的broker变为id为1的broker。</p><p>此时再去查看zookeeper中<code>/state</code>节点的数据，其中Isr列表可以看到变化：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;controller_epoch&quot;</span> <span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;leader&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;leader_epoch&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isr&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那么如果这时候再把brokerId为2的机器上的kafka服务启动呢，很明显能想到的就是brokerId=2重新加入了Isr的列表，但是Leader节点会有变化吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动broker.id为2机器上的服务后执行 --describe命令</span></span><br><span class="line">[root@localhost ~]<span class="comment"># kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test-multi-1</span></span><br><span class="line">Topic: test-multi-1     TopicId: uHfcZjY4T-SaBfR_ezgsXA PartitionCount: 2       ReplicationFactor: 3    Configs:</span><br><span class="line">        Topic: test-multi-1     Partition: 0    Leader: 1       Replicas: 2,1,0 Isr: 0,1,2</span><br><span class="line">        Topic: test-multi-1     Partition: 1    Leader: 1       Replicas: 1,0,2 Isr: 0,1,2</span><br></pre></td></tr></table></figure><p>我们可以看到Leader还是brokerId为1的机器，并没有因为brokerId为1的机器重新上线而把Leader交还给2，这样的好处是显而易见的，只有在某一个Broker宕机（网络断开）时进行一次选举，而加入时不用重新选举。同时这也会带来一定的风险，如果经过某一次宕机，大量Partition的Leader都被切换到某一个broker上，那么会导致单个broker的压力明显大于其他broker，这时候就需要用到Partition的自动平衡机制了。</p><h1 id="partition的leader自动平衡">Partition的Leader自动平衡</h1><p>在一组Partition中，Leader Partition通常是比较繁忙的节点，因为一个Leader节点既要负责和客户端通信，又要负责向Follower同步数据。一般情况下，Kafka会尽量均匀地把Leader分配的不同的Broker上，用以保证整个集群的压力均衡。</p><p>但是经过了Leader选举之后这种平衡就有可能被打破，如同上一小节最后的示例，两个分区的Leader节点在重新选举后变成了同一个Broker，并且在故障节点重新加入之后依然是未发生故障的节点作为两个分区的Leader节点。当一个集群中Leader Partition过多的集中在同一个Broker节点上时，这个Broker的压力就会明显高于其他Broker，从而影响到集群的整体性能。</p><p>为此，Kafka设计了Leader Partition的自动平衡机制，当发现Leader分配不均衡时，自动进行Leader Partition的调整。</p><p>在Kafka官方文档的<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#basic_ops_leader_balancing">Balancing leadership</a>中，详细描述了Kafka进行Leader Partition自动平衡的机制：</p><ul><li>Kafka默认从AR列表中取出第一个作为Leader节点。</li><li>Controller会定期检测集群的Partition平衡情况，如果发现某个Broker中Partition里作为Leader节点比例大于某个阈值（<code>leader.imbalance.per.broker.percentage</code>），那么就会触发一次自动平衡。自动平衡时判断是否处在Isr列表中，并根据AR列表的顺序优先确定为Leader节点。</li></ul><p>Kafka的自动平衡涉及到了一下几个参数的配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 自平衡开关。默认true</span></span><br><span class="line"><span class="attr">auto.leader.rebalance.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#2 自平衡扫描间隔。默认300</span></span><br><span class="line"><span class="attr">leader.imbalance.check.interval.seconds</span>=<span class="string">300</span></span><br><span class="line"><span class="comment">#3 自平衡触发比例。默认10</span></span><br><span class="line"><span class="attr">leader.imbalance.per.broker.percentage</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p>这几个参数可以到broker的server.properties文件中修改。但是注意要修改集群中所有broker的文件，并且要重启Kafka服务才能生效。</p><p>另外，也可以通过手动调用<code>kafka-leader-election.sh</code>脚本，触发一次自平衡。效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Leader平衡之前查看状态</span></span><br><span class="line">[root@localhost ~]<span class="comment"># kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test-multi-1</span></span><br><span class="line">Topic: test-multi-1     TopicId: uHfcZjY4T-SaBfR_ezgsXA PartitionCount: 2       ReplicationFactor: 3    Configs:</span><br><span class="line">        Topic: test-multi-1     Partition: 0    Leader: 1       Replicas: 2,1,0 Isr: 0,1,2</span><br><span class="line">        Topic: test-multi-1     Partition: 1    Leader: 1       Replicas: 1,0,2 Isr: 0,1,2</span><br><span class="line"><span class="comment"># 手动执行Leader选举</span></span><br><span class="line">[root@localhost ~]<span class="comment"># kafka-leader-election.sh --bootstrap-server localhost:9092 --topic test-multi-1 --election-type preferred --partition 0</span></span><br><span class="line">Successfully completed leader election (PREFERRED) <span class="keyword">for</span> partitions test-multi-1-0</span><br><span class="line"><span class="comment"># 再查看状态</span></span><br><span class="line">[root@localhost ~]<span class="comment"># kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic test-multi-1</span></span><br><span class="line">Topic: test-multi-1     TopicId: uHfcZjY4T-SaBfR_ezgsXA PartitionCount: 2       ReplicationFactor: 3    Configs:</span><br><span class="line">        Topic: test-multi-1     Partition: 0    Leader: 2       Replicas: 2,1,0 Isr: 0,1,2</span><br><span class="line">        Topic: test-multi-1     Partition: 1    Leader: 1       Replicas: 1,0,2 Isr: 0,1,2</span><br></pre></td></tr></table></figure><p>要注意的是，Leader Partition自平衡过程是一个比较重的操作，因为要涉及大量的消息转移和同步，并且在这个过程中可能会丢失消息。所以在对性能要求比较高的生产环境中，我们会把自动平衡设置为<code>false</code>，在业务比较少的时候由维护人员手动执行自平衡，尽量减少对业务的影响。</p><h1 id="partition故障恢复机制">Partition故障恢复机制</h1><p>为什么Leader Partition自平衡过程会导致消息丢失呢。这我们就要从一个Leader所在的Broker发生宕机，一直到对应Partition选举出新的Leader过程中去细细分析了。</p><p>从初始状态开始，一组Partition选举出一个Leader节点，这个Leader节点负责和客户端通信以及同步数据给其他Follower。当Leader节点所在的Broker宕机时，Kafka就会触发重新选举。</p><p>在介绍此时的数据处理过程前，我们先来了解一下Kafka在多个副本中同步消息的机制。</p><ul><li>LEO(Log End Offset)：在一个Partition的每个Replica中，都会保存自己的消息偏移量。Leader接收到消息并记录了生产者发布的一条消息之后就将LEO加1。接下来Follower每从Leader节点同步一条消息会把自己的LEO加1。</li><li>HW(High Watermark)：一组Partition中最小的LEO。Follower每从Leader节点同步一条消息时，会把自己的LEO给Leader，这样Leader根据Follower的LEO计算出HW的值，而最终HW又会同步给Follower。对于Leader来说，HW之前的消息都是被副本同步过的，是安全的消息。而从HW到LEO的消息都是不安全的，并且这些消息有可能被部分Follower同步，此时就可能出现消息数据的不一致。</li></ul><p>我们可以从下面表格中的结构直观的看一下。该Partition有3个副本，其中BrokerId为0的节点为Leader，此时Leader节点上接收到了最新的消息，共8条，LEO=8。BrokerId为1上的副本只同步了4条消息，LEO=4。BrokerId为2上的副本同步了6条消息，LEO=6。此时HW为4。</p><table style="width:100%"><colgroup><col style="width:30%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:7%"></colgroup><thead><tr class="header"><th>Replicas</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th></th></tr></thead><tbody><tr class="odd"><td>Broker_0(Leader)</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>LEO=8</td></tr><tr class="even"><td>Broker_1</td><td>0</td><td>1</td><td>2</td><td>3</td><td></td><td></td><td></td><td></td><td>LEO=4</td></tr><tr class="odd"><td>Broker_2</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td></td><td></td><td>LEO=6</td></tr></tbody></table><p>在这种情况下，只有LEO=4之前的消息可以被消费者感知，而后面的消息虽然写入了Leader，但是消费者是消费不到的。</p><p><em>注：这个无法感知和生产者的ack参数是不一样的。</em></p><p>当服务出现故障时，如果是Follower发生故障，这不会影响消息写入，只不过是少了一个备份而已。处理相对简单一点。Kafka会做如下处理：</p><ol type="1"><li>将故障的Follower节点临时提出ISR集合。而其他Leader和Follower继续正常接收消息。</li><li>出现故障的Follower节点恢复后，不会立即加入ISR集合。该Follower节点会读取本地记录的上一次的HW，将自己的日志中高于HW的部分信息全部删除掉，然后从HW开始，向Leader进行消息同步。</li><li>等到该Follower的LEO大于等于整个Partiton的HW后，就重新加入到ISR集合中。这也就是说这个Follower的消息进度追上了Leader。</li></ol><p>如果是Leader发生故障则会比较复杂：</p><ol type="1"><li>Leader节点发生故障后进行重新选举，将原本是Follower的节点升级为Leader。这时消息可能还没同步完，所以新的Leader的LEO会低于原Leader的LEO。</li><li>整个Partition都以Leader节点为准，所以其他Follower将高于新Leader的LEO的消息都清除，然后从新Leader同步数据。</li><li>旧的Leader恢复之后，作为Follower节点加入集群并从Leader同步消息。</li></ol><p>我们拿上面的示例举例：</p><p>如果此时Broker_0发生故障，根据ISR顺序<code>[0, 1, 2]</code>Broker_1被选举为Leader，此时新Leader的LEO为4，所以Broker_2作为Follower需要根据新的Leader的LEO删除对应的标识为4和5的消息。而后新的标识为8的消息就会由Broker_1接收并同步给Follower。这样一来，编号为4,5,6,7的4条消息就丢失了。</p><p>所以在整个崩溃恢复过程中，Kafka优先保证了副本间数据的一致性，而舍弃了安全性。因此在数据比较重要的金融领域，会使用更能保证安全性的RocketMQ，而Kafka更适合用于极端高性能而可以忍受部分数据丢失的场景。</p><h1 id="hw一致性保证">HW一致性保证</h1><p>上一小节中可以看到LEO是分布式的数据，每个Broker保存自己的数据，那么HW在各个Broker上是如何保持一致的呢？</p><p>这里直接给出结论，HW在一个Partition中并不是总是一致的。</p><p>Leader要计算出HW值，需要保留所有Follower的LEO。对于Follower来说，他需要先把消息从Leader拉取到本地，才能更新自己的LEO值，然后将LEO上报给Leader。此时Follower是无法马上得知HW是否会更新，因为更新HW的动作是由Leader完成的，并且是需要获取其他Follower数据的。只有当Leader推进HW后，在Follower下一次拉取消息时才会更新本机的HW。所以HW在Follower上的更新相比Leader还是存在一定的延迟。</p><h2 id="数据丢失问题">数据丢失问题</h2><p>当HW在Leader和Follower之间不一致时出现Leader的切换，新Leader根据自己保存的HW进行数据恢复，那么新Leader就会截掉自己的HW之后的消息，那么此时就会出现消息丢失。我们可以模拟一下以上的场景：</p><ol type="1"><li><p>当前状态：</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td>Leader</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>2</td><td>1</td><td>消息0，消息1</td></tr></tbody></table><p>此时Follower还未从Leader同步到最新的HW。</p></li><li><p>Follower重启，重启后将LEO重置到HW的值，并删除HW后面的消息。开始尝试重新从Leader同步消息。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td>Leader</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>1</td><td>1</td><td>消息0<del>，消息1</del></td></tr></tbody></table></li><li><p>Leader宕机，选举Follower为新的Leader。此时HW是1。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>（下线）</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td><del>Follower</del>-&gt;Leader</td><td>1</td><td>1</td><td>消息0</td></tr></tbody></table></li><li><p>原Leader重启后，作为Follower加入会自动向Leader看齐，截断HW后的日志文件，将HW置为1。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>-&gt;Follower</td><td>1</td><td>1</td><td>消息0</td></tr><tr class="even"><td>Broker_1</td><td>Leader</td><td>1</td><td>1</td><td>消息0</td></tr></tbody></table></li><li><p>经过这样一个故障恢复过程，消息1就从整个集群中彻底的移除了。</p></li></ol><p>由此可见，即使Kafka使用了HW保证HW以后的消息不对消费者可见，但是由于HW在整个集群中的更新延迟，依然会导致消息丢失。</p><h2 id="数据不一致问题">数据不一致问题</h2><p>当HW在Leader和Follower之间不一致时Leader和Follower同时重启，Follower先启动会导致其成为新的Leader并负责消息的接收，而后原Leader再启动成为Follower加入集群时，由于新Leader的HW也进行了更新，导致两边的HW一致但是消息却不一致的情况。我们可以模拟一下以上的场景：</p><ol type="1"><li><p>当前状态：</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td>Leader</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>2</td><td>1</td><td>消息0，消息1</td></tr></tbody></table><p>此时Follower还未从Leader同步到最新的HW。</p></li><li><p>Leader和Follower重启，重启后Follower先启动成功，并成为Leader节点，负责收发消息。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>（下线）</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td><del>Follower</del>-&gt;Leader</td><td>1</td><td>1</td><td>消息0<del>，消息1</del></td></tr></tbody></table><p>Broker_0: Leader（下线） LEO=2 HW=2 消息0，消息1</p><p>Broker_1: Follower-&gt;Leader LEO=1 HW=1 消息0</p></li><li><p>新Leader接收到新的消息，由于集群内仅有其一个节点，故能够更新HW。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>（下线）</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Leader</td><td>2</td><td>2</td><td>消息0，消息2</td></tr></tbody></table></li><li><p>原Leader重启后，作为Follower加入会自动向Leader看齐，发现HW是一致的，无需进行任何操作。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>-&gt;Follower</td><td>2</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>2</td><td>2</td><td>消息0，消息2</td></tr></tbody></table></li><li><p>经过这样一个重启过程，可以发现在两个副本中出现了消息的不一致。</p></li></ol><h1 id="问题的解决epoch">问题的解决——Epoch</h1><p>为了解决上面这两个问题，Kafka引入了Epoch机制。每个副本的Log下都有一个<code>leader-epoch-checkpoint</code>文件，用来记录Leader的纪元（版本）和对应的首条消息，在需要进行数据同步和日志截断时使用leader epoch作为参考，不再使用HW。</p><p>leader-epoch概念： Epoch是一个单调递增的版本号，每当Leader发生变更时，该版本号就会更新。所以，当有多个Epoch时，只有最新的Epoch才是有效的，而其他Epoch对应的Leader就是过期的，无用的Leader。同时，Epoch中记录了一个新的Leader写入的第一个消息的偏移量，用来同步数据。</p><p>数据结构为Leader Epoch（Leader版本号） -&gt; Start Offset（消息偏移量），可以从从具体文件中查看，其中第三行的两个数就是分别为Leader Epoch和Start Offset。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat leader-epoch-checkpoint</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1 16</span><br></pre></td></tr></table></figure><h2 id="解决数据丢失问题">解决数据丢失问题</h2><p>我们使用Epoch代替HW之后，模拟一下上一小节中的数据丢失的问题：</p><ol type="1"><li><p>当前状态：</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td>Leader</td><td>2</td><td>2</td><td>0</td><td>0</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>2</td><td>1</td><td>0</td><td>0</td><td>消息0，消息1</td></tr></tbody></table><p>此时Follower还未从Leader同步到最新的HW。</p></li><li><p>Follower重启，重启后不会将LEO重置到HW的值，而是根据LE向Leader获取LEO。由于Follower的LE与Leader的LE相同，Leader返回自己的LEO，此时Leader的LEO大于等于Follower的LEO，Follower不做截断。</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td>Leader</td><td>2</td><td>2</td><td>0</td><td>0</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>2</td><td>1</td><td>0</td><td>0</td><td>消息0，消息1</td></tr></tbody></table></li><li><p>Leader宕机，选举Follower为新的Leader。此时HW更新为2。而Epoch因为新的Leader产生了，所以生成了新的LE-&gt;Offset。</p><table style="width:100%"><colgroup><col style="width:14%"><col style="width:32%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:10%"><col style="width:21%"></colgroup><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>（下线）</td><td>2</td><td>2</td><td>0</td><td>0</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>2</td><td>2</td><td>1</td><td>2</td><td>消息0，消息1</td></tr></tbody></table></li><li><p>原Leader重启后，作为Follower加入会自动向Leader看齐。</p><table><colgroup><col style="width:13%"><col style="width:34%"><col style="width:6%"><col style="width:6%"><col style="width:6%"><col style="width:10%"><col style="width:20%"></colgroup><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>-&gt;Follower</td><td>2</td><td>2</td><td>1</td><td>2</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Leader</td><td>2</td><td>2</td><td>1</td><td>2</td><td>消息0，消息1</td></tr></tbody></table></li></ol><h2 id="解决数据不一致问题">解决数据不一致问题</h2><p>我们使用Epoch代替HW之后，模拟一下上一小节中的数据不一致的问题：</p><ol type="1"><li><p>当前状态：</p><table><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td>Leader</td><td>2</td><td>2</td><td>0</td><td>0</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Follower</td><td>1</td><td>1</td><td>0</td><td>0</td><td>消息0</td></tr></tbody></table><p>此时Follower还未从Leader同步到最新的消息。</p></li><li><p>Leader和Follower重启，重启后Follower先启动成功，并成为Leader节点，负责收发消息。同时Epoch因为新的Leader产生了，所以生成了新的LE-&gt;Offset。</p><table><colgroup><col style="width:13%"><col style="width:34%"><col style="width:6%"><col style="width:6%"><col style="width:6%"><col style="width:10%"><col style="width:20%"></colgroup><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>（下线）</td><td>2</td><td>2</td><td>0</td><td>0</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td><del>Follower</del>-&gt;Leader</td><td>1</td><td>1</td><td>1</td><td>1</td><td>消息0</td></tr></tbody></table></li><li><p>新Leader接收到新的消息，由于集群内仅有其一个节点，故能够更新HW。</p><table style="width:100%"><colgroup><col style="width:14%"><col style="width:32%"><col style="width:7%"><col style="width:7%"><col style="width:7%"><col style="width:10%"><col style="width:21%"></colgroup><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>（下线）</td><td>2</td><td>2</td><td>0</td><td>0</td><td>消息0，消息1</td></tr><tr class="even"><td>Broker_1</td><td>Leader</td><td>2</td><td>2</td><td>1</td><td>1</td><td>消息0，消息2</td></tr></tbody></table></li><li><p>原Leader重启后，作为Follower加入会自动向Leader看齐，根据LE向Leader获取LEO。此时Leader的LE和Follower的LE不同，Leader根据自己最新的LE和Offset，返回对应Offset为1。Follower根据新版本Leader的Offset截取数据，所以删除了消息1，从Leader同步消息2。</p><table><colgroup><col style="width:11%"><col style="width:28%"><col style="width:5%"><col style="width:5%"><col style="width:5%"><col style="width:8%"><col style="width:33%"></colgroup><thead><tr class="header"><th>节点</th><th>角色</th><th>LEO</th><th>HW</th><th>LE</th><th>Offset</th><th>消息列表</th></tr></thead><tbody><tr class="odd"><td>Broker_0</td><td><del>Leader</del>-&gt;Follower</td><td>2</td><td>2</td><td>1</td><td>1</td><td>消息0<del>，消息1</del>，消息2</td></tr><tr class="even"><td>Broker_1</td><td>Leader</td><td>2</td><td>2</td><td>1</td><td>1</td><td>消息0，消息2</td></tr></tbody></table></li></ol><h1 id="小结">小结</h1><p>Kafka天生就是为了集群而生，单个节点也可以成为一个Kafka集群。在Apache Kafka官网上第一句描述就是<code>Apache Kafka is an open-source distributed event streaming platform</code>。在服务器不稳定等复杂情况下，为了保证集群的高性能，高可用，高可扩展三高，做了非常多的设计。回看这一节中介绍的机制，都是为了保证整个集群中Partition内的数据的一致性，同时还能依靠其设计理念保证高性能和高可扩展。</p></div><footer class="post-footer"><div><div style="text-align:center;color:#ccc;font-size:14px">-------------　　　　本文结束　<i class="fa fa-flag"></i>　感谢阅读　　　　-------------</div></div><div class="reward-container"><div>请我一杯咖啡吧！</div> <button> 打赏</button><div class="post-reward"><div> <img src="https://myblog-1303447677.file.myqcloud.com/BlogFrame/wechatpay.png" alt=" 微信支付"> <span>微信支付</span></div><div> <img src="https://myblog-1303447677.file.myqcloud.com/BlogFrame/alipay.png" alt=" 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"></li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/" title="Kafka使用指南3——Kafka集群架构设计">https://zm6666.top/分布式框架Distribute-framework/How-to-use-Kafka-3-Cluster/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/Kafka/" rel="tag"><i class="fa fa-tag"></i> Kafka</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-1-InstallAndIntroduction-NativeUse/" rel="prev" title="Kafka使用指南1——简介和安装、原生命令行的使用"><i class="fa fa-angle-left"></i> Kafka使用指南1——简介和安装、原生命令行的使用</a></div><div class="post-nav-item"> <a href="/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-2-Java_Client/" rel="next" title="Kafka使用指南2——Java客户端以及Spring集成">Kafka使用指南2——Java客户端以及Spring集成<i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备2022038238号-1</a></div><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zm</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><script>var titleTime,OriginTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="来啊快活啊~"+OriginTitle,clearTimeout(titleTime)):(document.title="咚咚咚"+OriginTitle,titleTime=setTimeout(function(){document.title=OriginTitle},2e3))})</script></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"WYpTHDdtwSPYrGnPn3Dd6VK8-gzGzoHsz","app_key":"167XRDBA8P2enbdqnG3050K1","server_url":"https://wypthddt.lc-cn-n1-shared.com","security":true,"betterPerformance":true}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-Kafka-3-Cluster/"}</script><script src="/js/third-party/quicklink.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"zhaomin6666/BlogUtterances","issue_term":"title","theme":"github-light"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>
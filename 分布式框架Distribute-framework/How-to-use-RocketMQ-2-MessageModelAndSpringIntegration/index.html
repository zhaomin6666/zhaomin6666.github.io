<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico"><link rel="icon" type="image/png" sizes="32x32" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico"><link rel="icon" type="image/png" sizes="16x16" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico"><link rel="mask-icon" href="https://myblog-1303447677.file.myqcloud.com/BlogFrame/pig_32px_1271682_easyicon.net.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"zm6666.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="目录  RocketMQ简介和集群架构与原理 理解RocketMQ的消息模型并与Spring集成（本篇） RocketMQ源码解析 RocketMQ生产环境常见问题总结  主要内容 这一部分主要是了解RocketMQ的消息模型以及使用SpringBoot与服务端交互，主要就是为了学会项目上如何使用RocketMQ。"><meta property="og:type" content="article"><meta property="og:title" content="RocketMQ使用指南2——消息模型和Spring整合"><meta property="og:url" content="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/index.html"><meta property="og:site_name" content="Oli的生活杂谈"><meta property="og:description" content="目录  RocketMQ简介和集群架构与原理 理解RocketMQ的消息模型并与Spring集成（本篇） RocketMQ源码解析 RocketMQ生产环境常见问题总结  主要内容 这一部分主要是了解RocketMQ的消息模型以及使用SpringBoot与服务端交互，主要就是为了学会项目上如何使用RocketMQ。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-07-23T03:17:10.000Z"><meta property="article:modified_time" content="2024-09-23T14:51:49.290Z"><meta property="article:tag" content="Java"><meta property="article:tag" content="RocketMQ"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/","path":"分布式框架Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/","title":"RocketMQ使用指南2——消息模型和Spring整合"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>RocketMQ使用指南2——消息模型和Spring整合 | Oli的生活杂谈</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?a2fa2913e1140bc40e9aef85d103226c"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span><span class="toggle-line"></span><span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Oli的生活杂谈</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">2.</span> <span class="nav-text">主要内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%A7%A3rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">理解RocketMQ的消息模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">基本客户端使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">消息确认机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="nav-number">3.2.1.</span> <span class="nav-text">生产者消息确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E7%A1%AE%E8%AE%A4"><span class="nav-number">3.2.2.</span> <span class="nav-text">消费者消费确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%87%AA%E8%A1%8C%E8%AE%BE%E7%BD%AE%E6%B6%88%E8%B4%B9%E8%B5%B7%E7%82%B9"><span class="nav-number">3.2.3.</span> <span class="nav-text">消费者自行设置消费起点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF"><span class="nav-number">3.3.</span> <span class="nav-text">广播消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">顺序消息机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="nav-number">3.5.</span> <span class="nav-text">延迟消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="nav-number">3.6.</span> <span class="nav-text">批量消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%B6%88%E6%81%AF"><span class="nav-number">3.7.</span> <span class="nav-text">过滤消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-number">3.8.</span> <span class="nav-text">事务消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#acl%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-number">3.9.</span> <span class="nav-text">ACL权限控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot%E6%95%B4%E5%90%88rocketmq"><span class="nav-number">4.</span> <span class="nav-text">SpringBoot整合RocketMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA"><span class="nav-number">4.1.</span> <span class="nav-text">快速搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">处理不同消息类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">简单的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">4.2.2.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#push%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.3.1.</span> <span class="nav-text">Push模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pull%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">Pull模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.</span> <span class="nav-text">最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E7%90%86%E5%88%86%E9%85%8Dtopictag"><span class="nav-number">5.1.</span> <span class="nav-text">合理分配Topic、Tag</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8key%E5%8A%A0%E5%BF%AB%E6%B6%88%E6%81%AF%E7%B4%A2%E5%BC%95"><span class="nav-number">5.2.</span> <span class="nav-text">使用Key加快消息索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E6%B3%A8%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95"><span class="nav-number">5.3.</span> <span class="nav-text">关注错误消息重试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">5.4.</span> <span class="nav-text">手动处理死信队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-number">5.5.</span> <span class="nav-text">幂等性控制</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="" src="https://myblog-1303447677.file.myqcloud.com/BlogFrame/my-avatar.png"><p class="site-author-name" itemprop="name"></p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/zhaomin6666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaomin6666" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:lanmao_1029@163.com" title="E-Mail → mailto:lanmao_1029@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span></div><div class="cc-license animated" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://myblog-1303447677.file.myqcloud.com/BlogFrame/my-avatar.png"><meta itemprop="name" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Oli的生活杂谈"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="RocketMQ使用指南2——消息模型和Spring整合 | Oli的生活杂谈"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> RocketMQ使用指南2——消息模型和Spring整合</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-07-23 11:17:10" itemprop="dateCreated datePublished" datetime="2024-07-23T11:17:10+08:00">2024-07-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-09-23 22:51:49" itemprop="dateModified" datetime="2024-09-23T22:51:49+08:00">2024-09-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/" itemprop="url" rel="index"><span itemprop="name">分布式框架Distribute-framework</span></a></span></span><span id="/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/" class="post-meta-item leancloud_visitors" data-flag-title="RocketMQ使用指南2——消息模型和Spring整合" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><hr><h1 id="目录">目录</h1><ol type="1"><li><p>RocketMQ简介和集群架构与原理</p></li><li><p>理解RocketMQ的消息模型并与Spring集成（本篇）</p></li><li><p>RocketMQ源码解析</p></li><li><p>RocketMQ生产环境常见问题总结</p></li></ol><h1 id="主要内容">主要内容</h1><p>这一部分主要是了解RocketMQ的消息模型以及使用SpringBoot与服务端交互，主要就是为了学会项目上如何使用RocketMQ。</p><span id="more"></span><h1 id="理解rocketmq的消息模型">理解RocketMQ的消息模型</h1><p>我们从Java的客户端来演示RocketMQ的各项功能，从而进一步理解RocketMQ的消息模型。</p><h2 id="基本客户端使用">基本客户端使用</h2><p>新建一个Maven项目之后，引入客户端的核心依赖和权限控制相关的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>一个简单的消息生产者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个消息生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;basic_producer_group_name&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.30.3:9876&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动生产者</span></span><br><span class="line">            producer.start();</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;basic_topic&quot;</span>, <span class="string">&quot;basic_tag_A&quot;</span>, <span class="string">&quot;Hello RocketMQ&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的消息消费者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建⼀个消息消费者</span></span><br><span class="line">    <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;basic_consumer_group_name&quot;</span>);</span><br><span class="line">    <span class="comment">// 指定nameserver地址</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;192.168.30.3:9876&quot;</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅⼀个消息队列</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;basic_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (messageExtList, consumeConcurrentlyContext) -&gt; &#123;</span><br><span class="line">            messageExtList.forEach(messageExt -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody()));</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ的客户端编程模型相对比较固定，其实和其他消息中间件差不多，都有一个固定步骤。</p><ul><li>消息生产者的固定步骤<ol type="1"><li>创建消息生产者Producer，指定生产者组名</li><li>指定NameServer地址</li><li>启动Producer</li><li>创建消息对象，指定主题Topic、Tag和消息体</li><li>发送消息</li><li>关闭生产者Producer，释放资源</li></ol></li><li>消息消费者的固定步骤<ol type="1"><li>创建消费者Consumer，必须指定消费者组名</li><li>指定NameServer地址</li><li>订阅主题Topic和Tag</li><li>设置回调函数，处理消息</li><li>启动消费者Consumer。消费者会一直挂起持续接收消息。</li></ol></li></ul><p>其中最关键的就是NameServer，RocketMQ的客户端只需要指定NameServer地址，而不需要指定具体的Broker地址。我们在学习Kafka的设计中可以知道Kafka原来是指定的ZooKeeper地址（相当于是NameServer），后面版本是指定的Broker地址，这里双方就有不同点。</p><p>指定NameServer的方式有两种，一种是在客户端指定，例如<code>consuemr.setNameSrvAddr("node1:9876")</code>，或者通过读取系统环境变量来指定。</p><h2 id="消息确认机制">消息确认机制</h2><p>RocketMQ要支撑阿里的互联网金融场景，那么消息的安全性是必须优先进行保障的。而消息安全在客户端和服务端交互的时候有两个方面的要求，一个是生产者确保消息能够发送到Broker上，另一方面是消费者要能够确保从Broker上获取到消息。</p><h3 id="生产者消息确认">生产者消息确认</h3><p>针对消息的发送，RocketMQ客户端有三种选项可以给大家选择：</p><ol type="1"><li><p>单向发送：</p><p>单向发送的情况下，消息生产者只管往Broker里发送消息，而完全不管Broker是否成功接收到消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个消息生产者</span></span><br><span class="line">    <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;basic_producer_group_name&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;192.168.30.3:9876&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 创建消息对象</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;basic_topic&quot;</span>, <span class="string">&quot;basic_tag_A&quot;</span>, <span class="string">&quot;Hello RocketMQ&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        producer.sendOneway(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendOneway</code>方法没有返回值，如果失败，生产者也无法挽回。这种方式发送的效率最高，可以用于追求发送效率并且允许消息丢失的场景。</p></li><li><p>同步发送：</p><p>同步发送的情况下，生产者现场会等待broker的返回，直到broker返回接收结果，生产者才继续工作。代码就是一开始写的最基础的代码，直接使用<code>send</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br></pre></td></tr></table></figure><p><code>send</code>方法会有一个返回值，可以查看这个<code>SendResult</code>类中对于broker处理状态枚举类的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SendStatus</span> &#123;</span><br><span class="line">    SEND_OK, <span class="comment">// 发送成功</span></span><br><span class="line">    FLUSH_DISK_TIMEOUT, <span class="comment">// 刷盘超时</span></span><br><span class="line">    FLUSH_SLAVE_TIMEOUT, <span class="comment">// 同步slave节点超时</span></span><br><span class="line">    SLAVE_NOT_AVAILABLE, <span class="comment">// slave节点无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中很明显只有<code>SEND_OK</code>说明接收成功，如果生产者接收到的状态结果不是这个，就可以对发送失败的消息进行补救，比如重新发送。注意这里返回的状态只是broker接收成功，并不代表消费者能消费。并且状态如果是失败，broker也不是一定没有接收消息，补发可能会造成消息重复的可能，所以重新发送需要带上唯一标识，这样在消费者端才能做幂等判断。</p><p>这种同步发送的方式能够很大程度上保证消息发送的安全性，但是这种同步发送机制的发送效率比较低，send方法需要等待broker处理结果返回后才能继续执行，如果网络情况不佳，耗时会很长。</p></li><li><p>异步发送：</p><p>在异步发送机制下，生产者向Broker发送消息是，会同事注册一个回调函数。接下来生产者并不等待broker返回响应而是继续执行，当broker返回结果之后再出发回调函数进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">    <span class="comment">// 创建消息对象</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;basic_topic&quot;</span>, <span class="string">&quot;basic_tag_A&quot;</span>, (<span class="string">&quot;Hello RocketMQ &quot;</span> + index).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">finalIndex</span> <span class="operator">=</span> index;</span><br><span class="line">    producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">            <span class="comment">// broker处理成功</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, finalIndex, sendResult.getMsgId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">            <span class="comment">// broker处理失败</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, finalIndex, e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 都返回后释放资源</span></span><br><span class="line"><span class="keyword">if</span> (countDownLatch.await(<span class="number">5</span>, java.util.concurrent.TimeUnit.SECONDS)) &#123;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，和同步发送机制类似，触发了<code>onException</code>方法并不一定是处理失败，如果只是broker处理太慢也会导致超时，使用设置<code>producer.setSendMsgTimeout(3000);</code>可以自定义超时时间。</p><p>另外可以注意到上面的代码在发送时使用了<code>CountDownLatch</code>，因为只有在接收到所有结果之后才能关闭消费者主线程，否则启动的子线程也会随之关闭，就无法响应broker的返回结果了。</p><p>异步发送的机制是很多消息队列客户端都支持的方式，也是能够适应大部分场景的方式。当然，针对不同的业务场景需要更细致的考虑。</p></li></ol><h3 id="消费者消费确认">消费者消费确认</h3><p>对于消费者来说，要保证消费者消费消息，那就需要broker端等待客户端返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册消息监听器</span></span><br><span class="line">consumer.registerMessageListener((MessageListenerConcurrently) (messageExtList, consumeConcurrentlyContext) -&gt; &#123;</span><br><span class="line">    messageExtList.forEach(messageExt -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody()));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 返回处理结果</span></span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里返回的枚举值有两个选项：<code>CONSUME_SUCCESS</code>和<code>RECONSUME_LATER</code>。如果返回了<code>CONSUME_SUCCESS</code>那么说明消息消费成功，如果返回了<code>CONSUME_LATER</code>那么broker就会过一点时间再发起重试。</p><p>为了兼容重试机制的成功率和性能，RocketMQ设计了一套非常完善的消息重试机制。</p><ol type="1"><li>Broker不能无限制的向消费失败的消费者推送消息。如果消费者一直没有恢复，broker不可能不限制的推送。所以broker记录每个消息的重试次数，如果重试达到一定的次数这条消息就会被推入死信队列。待到消费者恢复正常，再人工从死信队列中对消息进行处理，可以是重新扔回正常的队列，也可以使用新的消费者消费他们，甚至直接删除。RocketMQ默认的最大重试次数为16次。</li><li>为了让这些重试的消息不会影响正常Topic下的其他正常消息，broker会给每一个消费者组设计对应的重试Topic，因为MessageQueue是一个具有严格FIFO特性的数据结构，如果在原队列上进行重试会导致长时间阻塞，影响性能。在消息需要进行重试时，会先移动到对应的重试Topic中，后续broker只要从这些重试Topic中不断拿出消息并往消费者组不断推送即可。</li><li>RocketMQ中设定的消费者组都是订阅主题和消费逻辑相同的服务备份，所以当消息进行重试时，broker只要把消息往消费者组中的任意一个推送即可，并不保证是上一次处理消息的消费者。这里就要注意，消费者组内的不同实例应当是逻辑相同的消费者服务，否则可能在业务上出现处理不一致的情况。</li><li>Broker端只能通过消费者返回的状态来确定消息有没有处理成功。至于消费者自己的业务执行是否出现异常，broker是无法感知的。因为消费者在处理业务逻辑时应尽量使用同步实现方式，保证在自己业务处理完成之后再向broker端返回状态。如果是异步处理业务逻辑，那么需要对异常进行捕获和监控。</li></ol><h3 id="消费者自行设置消费起点">消费者自行设置消费起点</h3><p>Broker通过Consumer返回的状态来推进所属消费者组对应的Offset。但是，这里会发现Consumer处理消息但是哪些消息需要处理又是由broker管理的，如果消息出现问题需要查询历史信息，又该怎么办。为此，RocketMQ虽然由broker管理offset，Consumer依然能够指定从某一个offset进行消费。在Consumer的属性中，可以设置一个<code>ConsumeFromWhere</code>属性，用于确定消费点位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ConsumeFromWhere</span> &#123;</span><br><span class="line">    CONSUME_FROM_LAST_OFFSET, <span class="comment">// 从上一次消费到的地方开始消费</span></span><br><span class="line">    CONSUME_FROM_FIRST_OFFSET, <span class="comment">// 从队列的第一条消息开始重新消费</span></span><br><span class="line">    CONSUME_FROM_TIMESTAMP; <span class="comment">// 从某一个时间戳开始消费</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ConsumeFromWhere</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果设置了<code>ConsumeFromWhere.CONSUME_FROM_TIMESTAMP</code>那么需要传入一个时间戳：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultConsumer.setConsumeTimestamp(<span class="string">&quot;20191024171201&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="广播消息">广播消息</h2><p>我们在RabbitMQ中学习过fanout交换机用于广播消息，它的核心是把消息发送的所有绑定的队列上。在Kafka中，我们需要使用多个消费者组去消费同一个Topic来实现广播。而在RocketMQ中，我们只需要设置消费者的消费模式为<code>consumer.setMessageModel(MessageModel.BROADCASTING);</code>，这样一个消息就会被多个消费者同时消费，不在关心消费者组的概念。</p><p>默认的集群模式（<code>MessageModel.CLUSTERING</code>）下，broker端维护每一个ConsumerGroup的Offset，这个offset可以保证消息在一个ComsumerGroup内只被消费一次。而广播模式下，broker将offset的管理交给消费者端，broker只管向所有消费者推送消息，不再负责维护消费进度。</p><p>注意，由于broker不再维护消费进度，所以消费者如果消费失败了，重试就只能由消费者自行处理。如果消费者重启，可以按照自行保存的上一次消费进度开始，处理后面没有消费过消息。不过一旦offset文件丢失，那么消费者就无法得知该从哪里开始消费了。</p><p>消费者的offset是保存在<code>/home/&#123;user&#125;/.rocketmq_offsets 中</code>，对应的路径可以参考<code>org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore</code>类中的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.storePath = LOCAL_OFFSET_STORE_DIR + File.separator +</span><br><span class="line">            <span class="built_in">this</span>.mQClientFactory.getClientId() + File.separator +</span><br><span class="line">            <span class="built_in">this</span>.groupName + File.separator +</span><br><span class="line">            <span class="string">&quot;offsets.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>客户端在运行时会不断尝试本地offset文件的写入，但是如果写入失败不会进行任何补救。</p><h2 id="顺序消息机制">顺序消息机制</h2><p>队列，很显然是一个FIFO的数据结构。但是消息队列对于顺序消息却不是默认实现的，比如Kafka就很难实现消息的顺序机制。RocketMQ提供了一种方式来实现顺序消费，见示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">businessId</span> <span class="operator">=</span> <span class="number">0</span>; businessId &lt; <span class="number">10</span>; businessId++) &#123;</span><br><span class="line">    <span class="comment">// 模拟10次业务过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 模拟1次业务的5个流程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">progressId</span> <span class="operator">=</span> businessId + <span class="string">&quot;_&quot;</span> + j;</span><br><span class="line">        <span class="comment">// 创建消息对象</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;consume_orderly_topic&quot;</span>, <span class="string">&quot;tag_business_&quot;</span> + businessId, <span class="string">&quot;key_&quot;</span> + progressId, (<span class="string">&quot;Hello RocketMQ &quot;</span> + progressId).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, (mqs, msg1, arg) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 这里的arg就是send方法的第三个参数businessId</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) arg;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> id % mqs.size();</span><br><span class="line">            <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">        &#125;, businessId);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到我们使用了<code>org.apache.rocketmq.client.producer.DefaultMQProducer#send(org.apache.rocketmq.common.message.Message, org.apache.rocketmq.client.producer.MessageQueueSelector, java.lang.Object)</code>方法来发送消息，这里第二个参数可以定义一个选择发送队列的选择器，选择器的实现中，我们根据业务的标识进行hash，保证同一个业务的多个流程都是发往broker中同一个队列的，这样可以保证这些消息发送到broker存储时是顺序的。</p><p>下面查看消费者客户端的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅⼀个消息队列</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;consume_orderly_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 注册消息监听器，这里监听器使用MessageListenerOrderly</span></span><br><span class="line">consumer.registerMessageListener((MessageListenerOrderly) (messageExtList, consumeOrderlyContext) -&gt; &#123;</span><br><span class="line">    consumeOrderlyContext.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    messageExtList.forEach(messageExt -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + messageExt.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody()));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动消费者</span></span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure><p>这里可以看到我们使用了<code>org.apache.rocketmq.client.consumer.DefaultMQPushConsumer#registerMessageListener(org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly)</code>方法来消费消息。和之前默认的监听不同，使用<code>MessageListenerOrderly</code>监听器不会启动并发的线程去拉取消息，而是使用一个线程去依次消费。当然在使用一个线程去消费的时候，一条消息在处理过程中时监听是阻塞的，需要处理一条消息之后才会拉取下一条消息，所以在这种场景下一般不会使用异步处理消息，也不会使用重试机制。</p><p>注意点：</p><ol type="1"><li>这边的有序保证的是局部有序，大部分业务场景下也是满足局部有序即可。如果要保持全局有序那么只能使用一个队列，效率会大大降低。</li><li>在对消息进行业务分组时，需要尽量将消息分散到不同的队列上来提高消费效率。</li><li>消费者端只能用同步方式处理，如果使用异步处理那么依然有可能导致顺序不一致。</li><li>消费者不能无限重试。如果消息处理失败，后面的消息都会阻塞，但消息失败次数达到RocketMQ最大重试次数跳过此消息，处理后面消息，就会导致消息乱序。</li><li>因为上一点，若消费者端如果确实处理逻辑出现问题，不建议抛出异常，可以返回<code>ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT</code>作为替代。</li></ol><h2 id="延迟消息">延迟消息</h2><p>延迟消息是指消息发送到消息队列之后不是马上投递消息，而是等待一段时间之后才投递到Consumer进行消费。RabbitMQ中可以通过消息的过期时间来利用死信队列的机制实现延迟消息，而Kafka则不太好实现这个功能。RocketMQ原生就可以支持。</p><p>代码中需要做的修改就只有一个，对消息设置一个延迟级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.setDelayTimeLevel(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里的延迟级别是和RocketMQ里设置的级别对应的，见<code>MessageStoreConfig</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure><p>现在RocketMQ并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18。18个等级无法调整，但是可以调整每个级别的延迟时间，总体来说还是不太灵活。在5.x的版本中，已经支持已经可以按秒的精度进行定时发送。</p><h2 id="批量消息">批量消息</h2><p>生产者要发送多条消息时，可以将多条消息合并发送，减少网络开销，这算是一种常见的优化方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line">List&lt;Message&gt; msgList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;batch_topic&quot;</span>, <span class="string">&quot;batch_tag_A&quot;</span>,</span><br><span class="line">                              (<span class="string">&quot;Hello RocketMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">    msgList.add(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msgList);</span><br></pre></td></tr></table></figure><p>批量消息的使用有一定的限制，同一批消息的Topic必须相同，并且不支持延迟消息。此外，这一批消息的总大小不应超过4MB。</p><h2 id="过滤消息">过滤消息</h2><p>同一个Topic下的所有消息也不一定是都是某一个消费者想要的，如果一个消费者想要特定属性的消息，那么就需要在发送阶段使用特殊的标签来标识。</p><ul><li><p>简单过滤：</p><p>生产者在发送消息时，使用Tag属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="comment">// 指定Tag属性</span></span><br><span class="line">String[] tags = &#123;<span class="string">&quot;basic_tag_A&quot;</span>, <span class="string">&quot;basic_tag_B&quot;</span>, <span class="string">&quot;basic_tag_C&quot;</span>, <span class="string">&quot;basic_tag_D&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line"><span class="keyword">for</span> (String tag : tags) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;basic_topic&quot;</span>, tag, <span class="string">&quot;Hello RocketMQ&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者在消费时根据Tag订阅消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅⼀个消息队列</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;basic_topic&quot;</span>, <span class="string">&quot;basic_tag_A&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，Consumer就只会处理Tag为<code>basic_tag_A</code>的消息。</p></li><li><p>SQL过滤</p><p>通过Tag属性只能进行简单的消息匹配。如果需要使用数字比较、模糊匹配等，就需要使用SQL过滤方式。SQL过滤方式可以通过Tag属性以及用户自定义的属性一起，使用标准的SQL方式进行消息过滤。</p><p>生产者在发送时除了Tag属性还要添加自定义属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;basic_topic&quot;</span>, <span class="string">&quot;basic_tag_A&quot;</span>, <span class="string">&quot;Hello RocketMQ&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"><span class="comment">// 设置自定义属性</span></span><br><span class="line">msg.putUserProperty(<span class="string">&quot;ATTRIBUTE&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>消费者在消费时创建一个SQL过滤器订阅消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅⼀个消息队列，使用sql过滤器过滤</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;basic_topic&quot;</span>, MessageSelector.bySql(</span><br><span class="line">    <span class="string">&quot;(TAGS in (&#x27;basic_tag_A&#x27;, &#x27;basic_tag_B&#x27;) AND (ATTRIBUTE is not null and ATTRIBUTE between 0 and 3))&quot;</span>));</span><br></pre></td></tr></table></figure><p>这个SQL语句的处理使用的是开源的ANLTR框架，这个框架也被用于ShardingSphere和Flink。</p><p>注意点：</p><ol type="1"><li>使用Tag过滤时，如果希望匹配多个Tag，可以使用两个竖线（<code>||</code>）连接多个Tag。另外，可以使用星号（<code>*</code>）匹配所有。</li><li>使用SQL过滤时，SQL语句按照SQL92标准，支持常见的SQL操作。如数值比较（<code>&gt;,&gt;=,&lt;,&lt;=,BETWEEN,=</code>）、字符比较（<code>=,&lt;&gt;,IN</code>）、空值（<code>IS NULL, IS NOT NULL</code>）、逻辑运算（<code>AND, OR, NOT</code>）。</li><li>消息过滤可以选择在消费者端做也可以选择在生产者端做。消费者端做就把消息标记不成功直接返回，这样可以减少服务端压力。我们使用服务端过滤可以提前完成过滤判断，减少不必要的IO，在RocketMQ服务端良好设计的前提下，应该尽量使用服务端过滤。</li><li>Consumer端不关心的数据不代表丢弃，应该在同一个消费者组内有其他消费者来消费掉这消息。</li></ol></li></ul><h2 id="事务消息">事务消息</h2><p>事务消息是用来保证上下游的数据一致性的，在电商等领域的场景非常需要这个功能来将子系统的数据变更串联到一起。</p><p>考虑到事务的安全性，那么要保证相关联的n个业务是同时成功或者失败的。假设一个流程的过程为主线程提交到RocketMQ（A1），3个消费者进行消费（A1.1，A1.2，A1.3），主线程执行A2。如要要把3个消费者服务和主线程用一个分布式事务来控制会很麻烦，但是如果使用RocketMQ串联起来就会比较简化。根据RocketMQ的消息确认以及重试机制，我们可以认为A1到A1.1、A1.2、A1.3这中间是保证最终数据一致性的。而此时只要再解决A1和A2的事务问题就可以了。由此，RocketMQ提出了两阶段提交的思路来实现事务一致性。</p><p>实现思路是这样的：</p><ol type="1"><li>生产者把消息发送到RocketMQ服务端。</li><li>服务端将消息持久化之后向生产者确认消息已经发送成功，此时消息在服务端被标记为暂不能投递，也称半事务消息。</li><li>生产者执行本地逻辑。</li><li>生产者根据本地逻辑的执行结果向服务端提交二次确认结果（Commit或者Rollback），服务端接收并进行处理。<ul><li>Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>Rollback：服务端将事务回滚，不会将半事务消息投递给消费者。</li></ul></li><li>在断网或者是生产者应用重启的特殊情况下，若服务端收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</li><li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li></ol><p>代码上，我们通过实现RocketMQ提供的接口<code>TransactionListener</code>来实现提交半事务后的业务执行和回查逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">transactionIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交半事务消息后执行本地逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o org.apache.rocketmq.client.producer.TransactionMQProducer#sendMessageInTransaction(org.apache</span></span><br><span class="line"><span class="comment">     *          .rocketmq.common.message.Message, java.lang.Object)中传入的自定义参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 事务状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(message.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端发起回查时客户端执行的代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageExt 回查的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 事务状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> localTrans.get(messageExt.getTransactionId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span> -&gt; LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                <span class="keyword">default</span> -&gt; LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者只需要把这个监听设置给对应RocketMQ提供的<code>TransactionMQProducer</code>类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个消息生产者</span></span><br><span class="line"><span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;transaction_producer_group_name&quot;</span>);</span><br><span class="line"><span class="comment">// 创建事务监听器</span></span><br><span class="line"><span class="type">TransactionListener</span> <span class="variable">transactionListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionListenerImpl</span>();</span><br><span class="line"><span class="comment">// 创建执行监听器中代码的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2000</span>), r -&gt; &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;);</span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line"><span class="comment">// 后面发送消息和普通的一样</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ol type="1"><li>半消息是对消费者不可见的消息，实际上，RocketMQ是将消息转到了一个系统Topic，<code>RMQ_SYS_TRANS_HALT_TOPIC</code>。然后二次提交的时候根据offset拿到消息执行最终的投递。参考<code>org.apache.rocketmq.broker.transaction.queue.TransactionalMessageServiceImpl#commitMessage</code>。</li><li>事务消息中，本地事务回查次数通过参数<code>transactionCheckMax</code>设定，默认15次。本地事务回查的间隔通过参数<code>transactionCheckInterval</code>设定，默认60秒。超过回查次数后，消息将会被丢弃。</li></ol><h2 id="acl权限控制">ACL权限控制</h2><p>RocketMQ提供了针对队列、用户等不同维度的非常全面的权限管理机制。通常来说RocketMQ作为一个内部服务是不需要进行权限控制的，但是如果消息队列是需要跨部门甚至跨公司合作使用的，那么权限控制的重要性就体现出来了。</p><ol type="1"><li><p>在控制平台可以针对Topic配置权限，比如设置这个Topic禁止读写、可读不可写、可读可写。</p></li><li><p>通过Broker端的配置文件可以更加详细的进行权限控制。打开<code>broker.conf</code>的<code>aclEnable</code>配置，然后通过<code>plain_acl.yml</code>文件进行配置，并且这个文件是热加载的，修改权限不需要重启服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span></span><br><span class="line">    <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span></span><br><span class="line">    <span class="attr">topicPerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicA=DENY</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">topicC=SUB</span></span><br><span class="line">    <span class="attr">groupPerms:</span></span><br><span class="line">      <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupA=DENY</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupB=SUB</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">groupC=SUB</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">    <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="string">.*</span></span><br><span class="line">    <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">    <span class="attr">admin:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置了权限信息之后，客户端再使用就需要通过accessKey和secretKey来提交身份信息了。引入对应的依赖包，并在声明生产者的时候传入RPCHook。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明身份信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ACL_ACCESS_KEY</span> <span class="operator">=</span> <span class="string">&quot;RocketMQ&quot;</span>;</span><br><span class="line">String  ACL_SECRET_KEY= <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"><span class="type">RPCHook</span> <span class="variable">rpcHook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AclClientRPCHook</span>(<span class="keyword">new</span> <span class="title class_">SessionCredentials</span>(ACL_ACCESS_KEY,ACL_SECRET_KEY));</span><br><span class="line"><span class="comment">// 初始化一个消息生产者</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;acl_producer_group_name&quot;</span>, rpcHook);</span><br></pre></td></tr></table></figure></li></ol><h1 id="springboot整合rocketmq">SpringBoot整合RocketMQ</h1><h2 id="快速搭建">快速搭建</h2><p>首先，pom文件引入相关包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加RocketMQ 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQSpringbootClientApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(RocketMQSpringbootClientApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq.name-server</span>=<span class="string">192.168.30.3:9876</span></span><br><span class="line"><span class="attr">rocketmq.producer.group</span>=<span class="string">springBootGroup</span></span><br><span class="line"><span class="comment">#rocketmq.consumer.topic=</span></span><br><span class="line"><span class="attr">rocketmq.consumer.group</span>=<span class="string">testGroup</span></span><br></pre></td></tr></table></figure><p>这里注解可以不配，但是就需要在消费者类的注解上配。</p><p>生产者很简单，直接注入使用<code>RocketMQTemplate</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicProducer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String topic, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rocketMQTemplate.convertAndSend(topic, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者实现提供的<code>RocketMQListener</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;BasicGroup&quot;, topic =</span></span><br><span class="line"><span class="meta">        &quot;BasicTopic&quot;, consumeMode = ConsumeMode.CONCURRENTLY, messageModel =</span></span><br><span class="line"><span class="meta">        MessageModel.BROADCASTING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理不同消息类型">处理不同消息类型</h2><h3 id="简单的使用">简单的使用</h3><p>可以参考<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq-spring/wiki">官方使用手册</a>。</p><h3 id="注意点">注意点</h3><p>一个RocketMQTemplate实例只能包含一个生产者，也就只能往一个Topic下发送消息。如果需要往另外一个Topic发送消息，需要使用<code>@ExtRocketMQTemplateConfiguration</code>注解并配置地址配合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtRocketMQTemplateConfiguration(nameServer = &quot;$&#123;rocketmqB.name-server&#125;&quot;,group = &quot;$&#123;rocketmqB.producer.group&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtRocketMQTemplate</span> <span class="keyword">extends</span> <span class="title class_">RocketMQTemplate</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtProducer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;extRocketMQTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate extRocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String topic, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.extRocketMQTemplate.convertAndSend(topic, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现原理">实现原理</h2><h3 id="push模式">Push模式</h3><p>Push模式就是上节实例中使用<code>@RocketMQMessageListener</code>注解声明的消费者。在Springboot的启动中，会对配置类进行加载，其中<code>ListenerContainerConfiguration</code>类负责了对这些消费者的初始化。</p><p>由于实现了<code>SmartInitializingSingleton</code>接口，在Spring容器完成非懒加载实例的加载后会调用<code>afterSingletonsInstantiated()</code>方法。我可以看到这个方法中会查找所有带有<code>@RocketMQMessageListener</code>注解的类并加入一个内部的map，并遍历调用<code>registerContainer</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; beans = <span class="built_in">this</span>.applicationContext.getBeansWithAnnotation(RocketMQMessageListener.class)</span><br><span class="line">        .entrySet().stream().filter(entry -&gt; !ScopedProxyUtils.isScopedTarget(entry.getKey()))</span><br><span class="line">        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line"></span><br><span class="line">    beans.forEach(<span class="built_in">this</span>::registerContainer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerContainer</code>方法比较重要，我们看一下大致的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerContainer</span><span class="params">(String beanName, Object bean)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获得类上的注解</span></span><br><span class="line">    <span class="type">RocketMQMessageListener</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(RocketMQMessageListener.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 校验注解配置</span></span><br><span class="line">    validate(annotation);</span><br><span class="line">    <span class="comment">// 将每个有注解的类转换成一个container并注册到上下文中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">containerBeanName</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s_%s&quot;</span>, DefaultRocketMQListenerContainer.class.getName(),</span><br><span class="line">                                             counter.incrementAndGet());</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">genericApplicationContext</span> <span class="operator">=</span> (GenericApplicationContext) applicationContext;</span><br><span class="line">    genericApplicationContext.registerBean(containerBeanName, DefaultRocketMQListenerContainer.class,</span><br><span class="line">                                           () -&gt; createRocketMQListenerContainer(containerBeanName, bean, annotation));</span><br><span class="line">    <span class="type">DefaultRocketMQListenerContainer</span> <span class="variable">container</span> <span class="operator">=</span> genericApplicationContext.getBean(containerBeanName, DefaultRocketMQListenerContainer.class);</span><br><span class="line">    <span class="comment">// 启动容器（启动消费者）</span></span><br><span class="line">    <span class="keyword">if</span> (!container.isRunning()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            container.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Started container failed. &#123;&#125;&quot;</span>, container, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;Register the listener to container, listenerBeanName:&#123;&#125;, containerBeanName:&#123;&#125;&quot;</span>, beanName, containerBeanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中主要是创建了一个<code>DefaultRocketMQListenerContainer</code>容器，这个容器中包含了我们自己写的消费者类，所以可以推测和RocketMQ的API交互的代码会在这个类里面去实现。接下来我们就重点看<code>DefaultRocketMQListenerContainer</code>的代码。<code>DefaultRocketMQListenerContainer</code>实现了<code>InitializingBean</code>接口，所以他的<code>afterPropertiesSet()</code>方法是重点。可以看到在方法中调用了<code>initRocketMQPushConsumer()</code>方法，看方法名就可以猜出来这是初始化消费者的代码。</p><p>在这个方法中，终于看到了RocketMQ原生的<code>DefaultMQPushConsumer</code>消费者，并且可以看到一些我们之前在基本客户端使用时用到的类似代码，下面我们大致来看下重点代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRocketMQPushConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 判断是否有权限控制并创建消费者类</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(rpcHook)) &#123;</span><br><span class="line">        consumer = <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(consumerGroup, rpcHook, <span class="keyword">new</span> <span class="title class_">AllocateMessageQueueAveragely</span>(), enableMsgTrace, <span class="built_in">this</span>.applicationContext.getEnvironment().resolveRequiredPlaceholders(<span class="built_in">this</span>.rocketMQMessageListener.customizedTraceTopic()));</span><br><span class="line">        consumer.setVipChannelEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Access-key or secret-key not configure in &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        consumer = <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(consumerGroup, enableMsgTrace, <span class="built_in">this</span>.applicationContext.getEnvironment().resolveRequiredPlaceholders(<span class="built_in">this</span>.rocketMQMessageListener.customizedTraceTopic()));</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.setNamespace(namespace);</span><br><span class="line">    <span class="comment">// 定制instanceName</span></span><br><span class="line">    consumer.setInstanceName(RocketMQUtil.getInstanceName(nameServer));</span><br><span class="line">    <span class="comment">// ... nameSever以及消费者属性的设置</span></span><br><span class="line">    <span class="comment">// 判断消费类型（广播、集群）</span></span><br><span class="line">    <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            consumer.setMessageModel(org.apache.rocketmq.common.protocol.heartbeat.MessageModel.BROADCASTING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            consumer.setMessageModel(org.apache.rocketmq.common.protocol.heartbeat.MessageModel.CLUSTERING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;messageModel&#x27; was wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤方式</span></span><br><span class="line">    <span class="keyword">switch</span> (selectorType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TAG:</span><br><span class="line">            consumer.subscribe(topic, selectorExpression);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SQL92:</span><br><span class="line">            consumer.subscribe(topic, MessageSelector.bySql(selectorExpression));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;selectorType&#x27; was wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定监听类（是否顺序消费）</span></span><br><span class="line">    <span class="keyword">switch</span> (consumeMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORDERLY:</span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">DefaultMessageListenerOrderly</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CONCURRENTLY:</span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">DefaultMessageListenerConcurrently</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Property &#x27;consumeMode&#x27; was wrong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pull模式">Pull模式</h3><p>Pull模式的实现是通过在<code>RocketMQTemplate</code>实例中注入<code>DefaultLitePullConsumer</code>实例来实现的。在注入了这个消费者实例之后，就可以使用template的<code>receive()</code>方法来调用消费者实例的<code>poll()</code>方法去主动Pull消息了。</p><p>我们从<code>RocketMQTemplate</code>类的<code>receive()</code>方法开始一步步找初始化的代码，可以看到<code>receive()</code>方法调用了<code>this.consumer.poll(timeout);</code>，其中变量consumer就是注入的消费者实例了，我们查找这个consumer的使用，找到<code>setConsumer()</code>方法的调用，可以看到在<code>RocketMQAutoConfiguration</code>这个配置类中对<code>RocketMQTemplate</code>实例的加载中会获取消费者实例并赋值给template实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line"><span class="meta">@Conditional(ProducerOrConsumerPropertyCondition.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = ROCKETMQ_TEMPLATE_DEFAULT_GLOBAL_NAME)</span></span><br><span class="line"><span class="keyword">public</span> RocketMQTemplate <span class="title function_">rocketMQTemplate</span><span class="params">(RocketMQMessageConverter rocketMQMessageConverter)</span> &#123;</span><br><span class="line">    <span class="type">RocketMQTemplate</span> <span class="variable">rocketMQTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RocketMQTemplate</span>();</span><br><span class="line">    <span class="keyword">if</span> (applicationContext.containsBean(PRODUCER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setProducer((DefaultMQProducer) applicationContext.getBean(PRODUCER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (applicationContext.containsBean(CONSUMER_BEAN_NAME)) &#123;</span><br><span class="line">        rocketMQTemplate.setConsumer((DefaultLitePullConsumer) applicationContext.getBean(CONSUMER_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    rocketMQTemplate.setMessageConverter(rocketMQMessageConverter.getMessageConverter());</span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>CONSUMER_BEAN_NAME</code>为<code>defaultLitePullConsumer</code>，所以我们找一下这个类的加载方法。依然是在<code>RocketMQAutoConfiguration</code>这个配置类中有<code>defaultLitePullConsumer</code>的初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(CONSUMER_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DefaultLitePullConsumer.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;rocketmq&quot;, value = &#123;&quot;name-server&quot;, &quot;consumer.group&quot;, &quot;consumer.topic&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DefaultLitePullConsumer <span class="title function_">defaultLitePullConsumer</span><span class="params">(RocketMQProperties rocketMQProperties)</span></span><br><span class="line">    <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">// ... 读取配置项</span></span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="type">DefaultLitePullConsumer</span> <span class="variable">litePullConsumer</span> <span class="operator">=</span> RocketMQUtil.createDefaultLitePullConsumer(nameServer, accessChannel, groupName, topicName, messageModel, selectorType, selectorExpression, ak, sk, pullBatchSize, useTLS);</span><br><span class="line">    litePullConsumer.setEnableMsgTrace(consumerConfig.isEnableMsgTrace());</span><br><span class="line">    litePullConsumer.setCustomizedTraceTopic(consumerConfig.getCustomizedTraceTopic());</span><br><span class="line">    litePullConsumer.setNamespace(consumerConfig.getNamespace());</span><br><span class="line">    <span class="keyword">return</span> litePullConsumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>RocketMQUtil.createDefaultLitePullConsumer()</code>方法就是创建了一个<code>DefaultLitePullConsumer</code>实例，相当于原生API中的拉模式客户端。</p><h1 id="最佳实践">最佳实践</h1><h2 id="合理分配topictag">合理分配Topic、Tag</h2><p>一个应用尽可能使用一个Topic，而消息子类型可以使用tags来标识。tags可以由应用自由设置，只有生产者在发送消息设置了tags，消费方在订阅消息时才可以利用tags通过broker做消息过滤。</p><p>虽然RocketMQ相较于Kafka在Topic过多的情况下性能已经有大幅优化，不会对消息转发的性能有影响，但是Topic过多还是会增加服务端对元数据维护的性能损耗，所以还是要尽量对Topic进行合理的分配。</p><p>对消息过滤时尽量使用Tag过滤，不要用复杂的SQL过滤，因为Tag是会写到索引里面的，这个在下一篇例会讲到。虽然使用SQL过滤能够减少更过的网络开销，但是毕竟会增加服务端的压力，所以消息过滤的逻辑还是越简单越好。</p><h2 id="使用key加快消息索引">使用Key加快消息索引</h2><p>分配好Topic和Tag之后，就要优化Key属性了，因为Key也可以参与消息过滤。通常每个消息要分配一个在业务层面的唯一标识码，设置到Key属性里。一方面可以配合Tag进行更精确的消息过滤，另一方面是RocketMQ服务端会对每个消息创建一个哈希索引，应用通过topic、key进行查询时，为了增加查询的效率，减小哈希冲突，客户端需要尽量保证key的唯一性。</p><h2 id="关注错误消息重试">关注错误消息重试</h2><p>如果消费者端的消息处理失败了，服务端会将消息进行重新投送。实际上，服务端会给每一个消费者组创建一个重试队列，重试的消息会进入一个<code>“%RETRY%” + ConsumerGroup</code>的队列中。</p><p>平时需要多关注重试队列，如果这个队列中出现了大量的消息，说明消费者的运行出现了问题。</p><p>每条消息默认最多重试16次，重试的间隔根据延迟消息级别的后16个级别判断。</p><p>如果重试16次后仍然失败，那么消息会转到死信队列。重试次数是可以设置的，使用<code>consumer.setMaxReconsumeTimes(20)</code>设置重试次数为20次。当超过16次之后，间隔固定为2小时。要注意的是，设置这个消费者的重试次数会对GroupId相同的所有Consumer同时生效，也就是整个GroupId相同的消费者集群会以设置了这个参数的最后一个启动的消费者为准。</p><h2 id="手动处理死信队列">手动处理死信队列</h2><p>消息进入死信队列说明在消费处理中这条消息出现了比较严重的错误，需要手动处理或者丢弃。</p><p>死信队列的名称是<code>%DLQ%+ConsumerGroup</code>，说明每一个死信队列对应一个ConsumerGroup，而不是对应某一个消费者实例。如果一个ConsumerGroup没有产生死信队列，RocketMQ也不会为其创建死信队列。而且一个消费者组内不管什么Topic的消息都在一个死信队列。</p><p>死信队列的消息不会再被消费者正常消费，默认也会因消息超时而被删除，默认为3天，对应<code>broker.conf</code>的<code>fileReservedTime</code>属性。</p><p>默认死信队列是禁读的，需要修改设置perm权限才能被消费。</p><h2 id="幂等性控制">幂等性控制</h2><p>我们在不同的消息队列的讨论中都会提到幂等性控制：</p><ul><li>at most once：使用异步发送或者sendOneWay可以保证</li><li>at least once：使用同步发送、事务消息等可以保证</li><li>exactly once：需要业务控制</li></ul><p>在发送、消费、服务重启（扩容、缩容）等场景下可能会出现消息重复的情况。在RocketMQ商业版确实提供了exactly once的相关API，而我们自己在使用的时候更多的是要在业务上保证消息不重复消费。比如使用messageID进行幂等性判断，但是messageID不是全局唯一的，如果能在业务上确认一个全局唯一的ID，作为Message的Key来传递是比较靠谱的。</p></div><footer class="post-footer"><div><div style="text-align:center;color:#ccc;font-size:14px">-------------　　　　本文结束　<i class="fa fa-flag"></i>　感谢阅读　　　　-------------</div></div><div class="reward-container"><div>请我一杯咖啡吧！</div> <button> 打赏</button><div class="post-reward"><div> <img src="https://myblog-1303447677.file.myqcloud.com/BlogFrame/wechatpay.png" alt=" 微信支付"> <span>微信支付</span></div><div> <img src="https://myblog-1303447677.file.myqcloud.com/BlogFrame/alipay.png" alt=" 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"></li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/" title="RocketMQ使用指南2——消息模型和Spring整合">https://zm6666.top/分布式框架Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/RocketMQ/" rel="tag"><i class="fa fa-tag"></i> RocketMQ</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-1-IntroductionAndCluster/" rel="prev" title="RocketMQ使用指南1——简介和集群部署"><i class="fa fa-angle-left"></i> RocketMQ使用指南1——简介和集群部署</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments utterances-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备2022038238号-1</a></div><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">zm</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><script>var titleTime,OriginTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="来啊快活啊~"+OriginTitle,clearTimeout(titleTime)):(document.title="咚咚咚"+OriginTitle,titleTime=setTimeout(function(){document.title=OriginTitle},2e3))})</script></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"WYpTHDdtwSPYrGnPn3Dd6VK8-gzGzoHsz","app_key":"167XRDBA8P2enbdqnG3050K1","server_url":"https://wypthddt.lc-cn-n1-shared.com","security":true,"betterPerformance":true}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://zm6666.top/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6Distribute-framework/How-to-use-RocketMQ-2-MessageModelAndSpringIntegration/"}</script><script src="/js/third-party/quicklink.js"></script><script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"zhaomin6666/BlogUtterances","issue_term":"title","theme":"github-light"}</script><script src="/js/third-party/comments/utterances.js"></script></body></html>